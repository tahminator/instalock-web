import {
  EntitlementApiType,
  RiotMatchInfoType,
  RiotUserInfoType,
} from "./autogenerated";

// Hoist the exported types out under the same namespace.
export * from "./autogenerated";

/**
 * The wrapper class for interacting with Riot's API.
 */
export class RiotClient {
  /**
   * Get the user info via an auth token.
   *
   * @see [valapidocs unofficial documentation](https://valapidocs.techchrism.me/endpoint/player-info)
   */
  static async getUserInfo(authToken: string) {
    const response = await fetch("https://auth.riotgames.com/userinfo", {
      headers: {
        Authorization: `Bearer ${authToken}`,
        "User-Agent": "ShooterGame/13 Windows/10.0.19043.1.256.64bit",
        "X-Riot-ClientVersion": "release-08.07-shipping-9-2444158",
      },
    });

    const json = response.json as () => Promise<RiotUserInfoType>;

    return { ...response, json };
  }

  /**
   * Get the entitlement token via an auth token.
   *
   * You will likely need both tokens for most routes that require authentication.
   *
   * @see [valapidocs unofficial documentation](https://valapidocs.techchrism.me/endpoint/entitlement)
   */
  static async getEntitlement(authToken: string) {
    const response = await fetch(
      "https://entitlements.auth.riotgames.com/api/token/v1",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${authToken}`,
          "Content-Type": "application/json",
        },
      },
    );

    const json = response.json as () => Promise<EntitlementApiType>;

    return { ...response, json };
  }

  /**
   * Get an array of matches (requires player UUID, authentication token, and entitlement token).
   * Supports pagination
   *
   * @see [valapidocs unofficial documentation](https://valapidocs.techchrism.me/endpoint/competitive-updates)
   */
  static async getCompetitiveUpdates({
    puuid,
    authToken,
    entitlementToken,
    startIndex = 0,
    endIndex = 1,
  }: {
    puuid: string;
    authToken: string;
    entitlementToken: string;
    startIndex?: number;
    endIndex?: number;
  }) {
    const response = await fetch(
      `https://pd.na.a.pvp.net/mmr/v1/players/${puuid}/competitiveupdates?startIndex=${startIndex}&endIndex=${endIndex}&queue=competitive`,
      {
        headers: {
          Authorization: `Bearer ${authToken}`,
          "X-Riot-Entitlements-JWT": entitlementToken,
          "X-Riot-ClientPlatform":
            "ew0KCSJwbGF0Zm9ybVR5cGUiOiAiUEMiLA0KCSJwbGF0Zm9ybU9TIjogIldpbmRvd3MiLA0KCSJwbGF0Zm9ybU9TVmVyc2lvbiI6ICIxMC4wLjE5MDQyLjEuMjU2LjY0Yml0IiwNCgkicGxhdGZvcm1DaGlwc2V0IjogIlVua25vd24iDQp9",
          "User-Agent": "ShooterGame/13 Windows/10.0.19043.1.256.64bit",
          "X-Riot-ClientVersion": "release-08.07-shipping-9-2444158",
        },
      },
    );

    const json = response.json as () => Promise<RiotMatchInfoType>;

    return { ...response, json };
  }

  /**
   * Get basic player data via an array of PUUIDs.
   * This basically lets you confirm if the users exists.
   *
   * @see [valapidocs unofficial documentation](https://valapidocs.techchrism.me/endpoint/name-service)
   */
  static async getPlayerByPuuid({
    authToken,
    entitlementToken,
    playerPuuids,
  }: {
    authToken: string;
    entitlementToken: string;
    playerPuuids: string[];
  }) {
    const response = await fetch(
      "https://pd.na.a.pvp.net/name-service/v2/players",
      {
        method: "PUT",
        body: JSON.stringify(playerPuuids),
        headers: {
          Authorization: `Bearer ${authToken}`,
          "X-Riot-Entitlements-JWT": entitlementToken ?? "",
          "X-Riot-ClientPlatform":
            "ew0KCSJwbGF0Zm9ybVR5cGUiOiAiUEMiLA0KCSJwbGF0Zm9ybU9TIjogIldpbmRvd3MiLA0KCSJwbGF0Zm9ybU9TVmVyc2lvbiI6ICIxMC4wLjE5MDQyLjEuMjU2LjY0Yml0IiwNCgkicGxhdGZvcm1DaGlwc2V0IjogIlVua25vd24iDQp9",
          "User-Agent": "ShooterGame/13 Windows/10.0.19043.1.256.64bit",
          "X-Riot-ClientVersion": "release-08.07-shipping-9-2444158",
        },
      },
    );

    const json = response.json as () => Promise<
      {
        DisplayName: string;
        Subject: string;
        GameName: string;
        TagLine: string;
      }[]
    >;

    return { ...response, json };
  }
}
